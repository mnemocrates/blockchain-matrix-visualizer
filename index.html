
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bitcoin Block – Data-Driven Matrix (mempool.space)</title>
  <style>
    :root {
      --matrix-green: #00ff7f;
      --matrix-dim: #00aa55;
      --matrix-deep: #008844;
      --bg-black: #000000;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --panel-bg: rgba(0, 0, 0, 0.6);
    }
    html, body {
      width: 100%; height: 100%;
      margin: 0; background: var(--bg-black);
      color: var(--matrix-green);
      font-family: var(--mono);
      overflow: hidden;
    }
    #canvas { position: fixed; inset: 0; display: block; background: #000; }
    #overlay {
      position: fixed; top: 1rem; left: 1rem;
      background: var(--panel-bg); border: 1px solid var(--matrix-dim);
      padding: 0.75rem 1rem; border-radius: 6px; backdrop-filter: blur(2px);
      box-shadow: 0 0 12px rgba(0,255,127,0.2); max-width: min(92vw, 56rem);
      cursor: pointer; transition: all 0.3s ease;
    }
    #overlay:hover { box-shadow: 0 0 18px rgba(0,255,127,0.35); }
    #overlay h1 {
      margin: 0 0 0.5rem 0; font-size: 1rem; letter-spacing: 0.08em;
      color: var(--matrix-green); text-shadow: 0 0 6px rgba(0,255,127,0.35);
      display: flex; align-items: center; gap: .5rem; flex-wrap: wrap;
    }
    #toggle-icon {
      margin-left: auto; font-size: 1.2rem; transition: transform 0.3s ease;
      user-select: none;
    }
    #overlay.collapsed #toggle-icon { transform: rotate(-90deg); }
    #overlay.collapsed #block-info,
    #overlay.collapsed #legend {
      max-height: 0; overflow: hidden; opacity: 0;
      margin: 0; transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    }
    #block-info, #legend {
      max-height: 1000px; opacity: 1;
      transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    }
    .pill {
      border: 1px solid var(--matrix-dim); border-radius: 999px;
      padding: 0.1rem 0.5rem; font-size: 0.85rem; color: var(--matrix-green);
    }
    #overlay pre { margin: 0.25rem 0 0 0; white-space: pre-wrap; word-break: break-all; color: var(--matrix-dim); line-height: 1.25; }
    #legend { margin-top: .5rem; color: var(--matrix-deep); font-size: .85rem; }
    #status {
      position: fixed; right: 1rem; bottom: 1rem;
      color: var(--matrix-dim); font-size: 0.8rem;
      background: var(--panel-bg); padding: .35rem .5rem; border-radius: 4px;
      border: 1px solid var(--matrix-dim);
    }
    a { color: var(--matrix-green); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .hidden-ui { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="overlay" class="collapsed hidden-ui">
    <h1>
      Latest Block ▮ Bitcoin <span class="pill">main</span>
      <span id="height" class="pill">Height: —</span>
      <span id="age" class="pill">Age: —</span>
      <span id="txcount" class="pill">Tx: —</span>
      <span id="source" class="pill">https://mempool.space/mempool.space</a></span>
      <span id="toggle-icon">▼</span>
    </h1>
    <pre id="block-info">Loading…</pre>
    <div id="legend">⬅︎ Block Header (left ~25%) • UTXO Data: addresses, amounts ₿, hashes (right ~75%)</div>
  </div>

  <div id="status" class="hidden-ui">Matrix connected to mempool.space…</div>

  <script>
    // ===== CONFIGURATION LOADING =====
    let CONFIG = null;
    
    async function loadConfig() {
      try {
        const response = await fetch('config.json');
        if (!response.ok) throw new Error('Config file not found');
        const config = await response.json();
        
        // Flatten the nested structure for easier access
        return {
          // Display Layout
          headerColumnPercentage: config.display.headerColumnPercentage,
          showUIOnLoad: config.display.showUIOnLoad,
          initiallyCollapsed: config.display.initiallyCollapsed,
          
          // Matrix Visual Settings
          fontSize: config.matrix.fontSize,
          matrixSpeed: config.matrix.matrixSpeed,
          trailLengthMin: config.matrix.trailLengthMin,
          trailLengthMaxPercent: config.matrix.trailLengthMaxPercent,
          fadeStartOpacity: config.matrix.fadeStartOpacity,
          fadeExponent: config.matrix.fadeExponent,
          backgroundFadeAlpha: config.matrix.backgroundFadeAlpha,
          resetProbability: config.matrix.resetProbability,
          headCycleFrames: config.matrix.headCycleFrames || 8,
          headCycleChars: config.matrix.headCycleChars || 'abcdefghijklmnopqrstuvwxyz0123456789',
          enableBackgroundLayer: config.matrix.enableBackgroundLayer !== false,
          backgroundLayerOpacity: config.matrix.backgroundLayerOpacity || 0.35,
          backgroundLayerSpeed: config.matrix.backgroundLayerSpeed || 0.4,
          
          // Colors
          primaryColor: config.colors.primaryColor,
          goldColor: config.colors.goldColor,
          cyclingColor: config.colors.cyclingColor || '#00ffff',
          gradientStartRGB: config.colors.gradientStartRGB,
          gradientEndRGB: config.colors.gradientEndRGB,
          
          // API Settings
          apiBase: config.api.apiBase,
          blockRefreshInterval: config.api.blockRefreshInterval,
          ageUpdateInterval: config.api.ageUpdateInterval,
          transactionFetchLimit: config.api.transactionFetchLimit,
          
          // Keyboard
          toggleKey: config.keyboard.toggleKey,
          
          // Transitions
          transitionEffect: config.transitions?.effectType || 'none',
          glitchDuration: config.transitions?.glitchDuration || 300,
          glitchIntensity: config.transitions?.glitchIntensity || 0.15,
        };
      } catch (error) {
        console.error('Failed to load config, using defaults:', error);
        // Return default configuration
        return {
          headerColumnPercentage: 0.25,
          showUIOnLoad: false,
          initiallyCollapsed: true,
          fontSize: 18,
          matrixSpeed: 0.5,
          trailLengthMin: 5,
          trailLengthMaxPercent: 0.8,
          fadeStartOpacity: 0.5,
          fadeExponent: 2,
          backgroundFadeAlpha: 0.15,
          resetProbability: 0.975,
          headCycleFrames: 8,
          headCycleChars: 'abcdefghijklmnopqrstuvwxyz0123456789',
          enableBackgroundLayer: true,
          backgroundLayerOpacity: 0.35,
          backgroundLayerSpeed: 0.4,
          primaryColor: '#00ff7f',
          goldColor: '#FFD700',
          cyclingColor: '#00ffff',
          gradientStartRGB: [0, 170, 85],
          gradientEndRGB: [0, 136, 68],
          apiBase: 'https://mempool.space/api',
          blockRefreshInterval: 30000,
          ageUpdateInterval: 1000,
          transactionFetchLimit: 15,
          toggleKey: 's',
          transitionEffect: 'none',
          glitchDuration: 300,
          glitchIntensity: 0.15,
        };
      }
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let W = window.innerWidth, H = window.innerHeight;
    let fontSize = 18; // Will be updated from config
    canvas.width = W; canvas.height = H;

    let columns = Math.floor(W / fontSize);
    let drops = [];
    let columnPools = [];
    let columnPoolColors = []; // Track which characters in pool should be gold
    let columnIndex = [];
    let columnHue = [];
    let columnTrailLength = [];
    let columnChars = []; // Current character for each column
    let columnLastPos = []; // Track last integer position
    let columnCharHistory = []; // History buffer for trailing characters
    let columnColorHistory = []; // Color history for each character
    let columnCycleFrames = []; // Remaining frames to cycle head character
    let columnActualChar = []; // The actual character to display after cycling
    
    // ===== BACKGROUND LAYER (for depth) =====
    let bgDrops = [];
    let bgChars = [];
    let bgLastPos = [];
    let bgTrailLength = [];
    let bgCharHistory = [];
    
    // ===== TRANSITION EFFECTS =====
    let transitionActive = false;
    let transitionStartTime = 0;
    let glitchOriginalPools = [];
    let glitchOriginalIndices = [];

    function triggerTransition() {
      if (!CONFIG || CONFIG.transitionEffect === 'none') return;
      
      transitionActive = true;
      transitionStartTime = Date.now();
      
      // Prepare effect-specific data
      if (CONFIG.transitionEffect === 'glitch') {
        // Store original state
        glitchOriginalPools = columnPools.map(p => p);
        glitchOriginalIndices = columnIndex.map(i => i);
      }
    }
    
    function applyGlitchEffect() {
      const elapsed = Date.now() - transitionStartTime;
      const duration = CONFIG.glitchDuration;
      
      if (elapsed >= duration) {
        // Restore original state
        transitionActive = false;
        return;
      }
      
      // Randomly scramble characters based on intensity
      const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?/~`';
      for (let i = 0; i < columns; i++) {
        if (Math.random() < CONFIG.glitchIntensity) {
          // Scramble this column's character
          if (Math.random() < 0.5) {
            // Use random glitch character
            columnChars[i] = glitchChars[Math.floor(Math.random() * glitchChars.length)];
          } else {
            // Use random character from a different column's pool
            const randomCol = Math.floor(Math.random() * columns);
            const randomPool = columnPools[randomCol] || glitchChars;
            columnChars[i] = randomPool[Math.floor(Math.random() * randomPool.length)];
          }
        }
      }
    }
    
    function updateTransition() {
      if (!transitionActive) return;
      
      switch (CONFIG.transitionEffect) {
        case 'glitch':
          applyGlitchEffect();
          break;
        // Future effects can be added here:
        // case 'cascade': applyCascadeEffect(); break;
        // case 'flash': applyFlashEffect(); break;
      }
    }

    function initColumns() {
      if (!CONFIG) return; // Wait for config to load
      
      columns = Math.floor(W / fontSize);
      drops = Array(columns).fill(0).map(() => Math.random() * H / fontSize);
      columnPools = Array(columns).fill('');
      columnPoolColors = Array(columns).fill(null).map(() => []);
      columnIndex = Array(columns).fill(0);
      columnHue = Array(columns).fill(CONFIG.primaryColor);
      const maxTrail = Math.floor(H / fontSize * CONFIG.trailLengthMaxPercent);
      columnTrailLength = Array(columns).fill(0).map(() => Math.floor(CONFIG.trailLengthMin + Math.random() * (maxTrail - CONFIG.trailLengthMin)));
      columnChars = Array(columns).fill('');
      columnLastPos = Array(columns).fill(-1);
      columnCharHistory = Array(columns).fill(null).map(() => []);
      columnColorHistory = Array(columns).fill(null).map(() => []);
      columnCycleFrames = Array(columns).fill(0);
      columnActualChar = Array(columns).fill('');
      
      // Initialize background layer streams (between main columns)
      if (CONFIG.enableBackgroundLayer) {
        bgDrops = Array(columns).fill(0).map(() => Math.random() * H / fontSize);
        bgChars = Array(columns).fill('');
        bgLastPos = Array(columns).fill(-1);
        const maxTrailBg = Math.floor(H / fontSize * CONFIG.trailLengthMaxPercent * 0.8); // Slightly shorter
        bgTrailLength = Array(columns).fill(0).map(() => Math.floor(CONFIG.trailLengthMin + Math.random() * (maxTrailBg - CONFIG.trailLengthMin)));
        bgCharHistory = Array(columns).fill(null).map(() => []);
      }
    }

    window.addEventListener('resize', () => {
      W = window.innerWidth; H = window.innerHeight;
      canvas.width = W; canvas.height = H;
      if (CONFIG) {
        initColumns();
        assignPoolsFromData(latestGlyphs);
      }
    });

    function nextGlyph(i) {
      const pool = columnPools[i] || '0123456789abcdef';
      if (!pool.length) return ' ';
      const ch = pool[columnIndex[i] % pool.length];
      columnIndex[i] = (columnIndex[i] + 1) % pool.length;
      return ch;
    }

    function drawMatrix() {
      // Update transition effects
      updateTransition();
      
      ctx.fillStyle = `rgba(0, 0, 0, ${CONFIG.backgroundFadeAlpha})`;
      ctx.fillRect(0, 0, W, H);
      ctx.font = `${fontSize}px monospace`;

      // ===== DRAW BACKGROUND LAYER (for depth) =====
      if (CONFIG.enableBackgroundLayer) {
        for (let i = 0; i < bgDrops.length; i++) {
          const currentPos = Math.floor(bgDrops[i]);
          
          // Get new character when position changes
          if (currentPos !== bgLastPos[i]) {
            const pool = columnPools[i] || '0123456789abcdef';
            bgChars[i] = pool[Math.floor(Math.random() * pool.length)];
            bgLastPos[i] = currentPos;
            bgCharHistory[i].unshift(bgChars[i]);
            if (bgCharHistory[i].length > Math.floor(H / fontSize)) {
              bgCharHistory[i].length = Math.floor(H / fontSize);
            }
          }
          
          const ch = bgChars[i];
          // Offset x position to fall between main columns
          const x = i * fontSize + fontSize * 0.5;
          const y = currentPos * fontSize;
          
          // Parse primary color RGB
          const colorHex = CONFIG.primaryColor;
          const r = parseInt(colorHex.slice(1, 3), 16);
          const g = parseInt(colorHex.slice(3, 5), 16);
          const b = parseInt(colorHex.slice(5, 7), 16);
          
          // Draw head at reduced opacity
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${CONFIG.backgroundLayerOpacity})`;
          ctx.fillText(ch, x, y);
          
          // Draw trail
          const trailLen = bgTrailLength[i];
          for (let j = 1; j <= trailLen; j++) {
            const trailY = y - (j * fontSize);
            if (trailY < -fontSize || trailY > H) continue;
            
            const fadeRatio = j / trailLen;
            const opacity = CONFIG.backgroundLayerOpacity * CONFIG.fadeStartOpacity * Math.pow(1 - fadeRatio, CONFIG.fadeExponent);
            
            if (opacity > 0.02) {
              const trailChar = bgCharHistory[i][j] || ch;
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
              ctx.fillText(trailChar, x, trailY);
            }
          }
          
          if (y > H && Math.random() > CONFIG.resetProbability) bgDrops[i] = 0;
          bgDrops[i] += CONFIG.backgroundLayerSpeed;
        }
      }

      // ===== DRAW PRIMARY LAYER =====
      for (let i = 0; i < drops.length; i++) {
        const currentPos = Math.floor(drops[i]);
        
        // Only get new character when position changes
        if (currentPos !== columnLastPos[i]) {
          columnActualChar[i] = nextGlyph(i);
          columnLastPos[i] = currentPos;
          // Start cycling animation at head
          columnCycleFrames[i] = CONFIG.headCycleFrames;
          
          // Get color from pool color array
          const poolColors = columnPoolColors[i];
          const idx = (columnIndex[i] - 1 + poolColors.length) % poolColors.length;
          const isGold = poolColors[idx] || false;
          
          // Immediately add to history with the actual character
          columnCharHistory[i].unshift(columnActualChar[i]);
          columnColorHistory[i].unshift(isGold);
          
          // Keep history buffer size manageable
          const maxHistory = Math.floor(H / fontSize);
          if (columnCharHistory[i].length > maxHistory) {
            columnCharHistory[i].length = maxHistory;
            columnColorHistory[i].length = maxHistory;
          }
        }
        
        // Handle head character cycling (only at current position)
        if (columnCycleFrames[i] > 0) {
          // Cycle through random characters from cycle pool
          const cyclePool = CONFIG.headCycleChars;
          columnChars[i] = cyclePool[Math.floor(Math.random() * cyclePool.length)];
          columnCycleFrames[i]--;
        } else {
          // Cycling complete, use actual character
          columnChars[i] = columnActualChar[i];
        }
        
        const ch = columnChars[i];
        const x = i * fontSize;
        const y = currentPos * fontSize;

        // Bright leading character (always at full brightness during cycling)
        if (columnCycleFrames[i] > 0) {
          // Cycling: use bright cyan color for emphasis
          ctx.fillStyle = CONFIG.cyclingColor;
        } else {
          // Normal: use appropriate color (gold for bitcoin amounts)
          const isGoldChar = columnColorHistory[i][0];
          ctx.fillStyle = isGoldChar ? CONFIG.goldColor : columnHue[i];
        }
        ctx.fillText(ch, x, y);

        // Draw variable length fading trail
        const baseHue = columnHue[i];
        let r, g, b;
        if (baseHue.startsWith('#')) {
          r = parseInt(baseHue.slice(1, 3), 16);
          g = parseInt(baseHue.slice(3, 5), 16);
          b = parseInt(baseHue.slice(5, 7), 16);
        } else if (baseHue.startsWith('rgb')) {
          const match = baseHue.match(/\d+/g);
          if (match) {
            r = parseInt(match[0]);
            g = parseInt(match[1]);
            b = parseInt(match[2]);
          } else {
            r = 0; g = 170; b = 85;
          }
        } else {
          r = 0; g = 170; b = 85;
        }
        
        // Draw trailing characters with exponential fade for readability
        const trailLen = columnTrailLength[i];
        const history = columnCharHistory[i];
        for (let j = 1; j <= trailLen; j++) {
          const trailY = y - (j * fontSize);
          if (trailY < -fontSize || trailY > H) continue;
          
          // Exponential fade with configurable parameters
          const fadeRatio = j / trailLen;
          const opacity = CONFIG.fadeStartOpacity * Math.pow(1 - fadeRatio, CONFIG.fadeExponent);
          
          if (opacity > 0.05) {
            // Use character from history if available, otherwise current char
            const trailChar = history[j] || ch;
            const trailIsGold = columnColorHistory[i][j];
            if (trailIsGold) {
              const [gr, gg, gb] = [255, 215, 0]; // Gold RGB
              ctx.fillStyle = `rgba(${gr}, ${gg}, ${gb}, ${opacity})`;
            } else {
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            ctx.fillText(trailChar, x, trailY);
          }
        }

        if (y > H && Math.random() > CONFIG.resetProbability) drops[i] = 0;
        drops[i] += CONFIG.matrixSpeed;
      }
      requestAnimationFrame(drawMatrix);
    }

    // ===== Initialize UI Visibility =====
    const overlayEl = document.getElementById('overlay');
    const statusEl = document.getElementById('status');
    
    function applyUIVisibility() {
      if (!CONFIG.showUIOnLoad) {
        // UI starts hidden (keep hidden-ui class)
      } else {
        // Show UI on load
        overlayEl.classList.remove('hidden-ui');
        statusEl.classList.remove('hidden-ui');
      }
      
      if (!CONFIG.initiallyCollapsed) {
        overlayEl.classList.remove('collapsed');
      }
    }

    // ===== Keyboard Toggle =====
    window.addEventListener('keydown', (e) => {
      if (!CONFIG) return;
      const key = e.key.toLowerCase();
      if (key === CONFIG.toggleKey.toLowerCase()) {
        overlayEl.classList.toggle('hidden-ui');
        statusEl.classList.toggle('hidden-ui');
      }
    });

    // ===== Expandable Header =====
    overlayEl.addEventListener('click', () => {
      overlayEl.classList.toggle('collapsed');
    });

    // ===== Live Data =====
    const heightPill = document.getElementById('height');
    const agePill = document.getElementById('age');
    const txPill = document.getElementById('txcount');
    const infoEl = document.getElementById('block-info');
    const sourceLink = document.getElementById('sourceLink');

    let API_BASE = 'https://mempool.space/api';
    let lastHash = null;
    let latestBlock = null;
    let latestGlyphs = null;

    function setStatus(msg) { statusEl.textContent = msg; }
    function toLowerStr(val) { return (val ?? '') === '' ? '' : String(val).toLowerCase(); }
    function toHexStr(val) {
      if (val === undefined || val === null) return '';
      if (typeof val === 'string') return val.toLowerCase();
      if (typeof val === 'number') { try { return (val >>> 0).toString(16); } catch { return String(val); } }
      return String(val).toLowerCase();
    }
    function hexToAsciiSafe(hex) {
      if (!hex || typeof hex !== 'string') return '';
      const cleaned = hex.replace(/[^0-9a-fA-F]/g, '');
      let out = '';
      for (let i = 0; i < cleaned.length; i += 2) {
        const b = parseInt(cleaned.slice(i, i + 2), 16);
        if (!isNaN(b)) {
          const ch = String.fromCharCode(b);
          if (ch >= ' ' && ch <= '~') out += ch;
        }
      }
      return out.toLowerCase();
    }
    function updateAgePill(block) {
      if (!block || !block.timestamp) { agePill.textContent = 'Age: —'; return; }
      const secs = Math.max(0, Math.floor(Date.now()/1000) - block.timestamp);
      const mins = Math.floor(secs / 60);
      const rem = secs % 60;
      agePill.textContent = `Age: ${mins}m ${rem}s`;
    }

    function renderOverlay(block, txCount, coinbaseAscii) {
      heightPill.textContent = `Height: ${block.height ?? '—'}`;
      txPill.textContent = `Tx: ${txCount ?? '—'}`;

      const lines = [
        `Hash:       ${block.id ?? block.hash ?? '—'}`,
        `Time:       ${block.timestamp ? new Date(block.timestamp * 1000).toISOString() + ' (' + block.timestamp + ')' : '—'}`,
        `Tx Count:   ${txCount ?? '—'}`,
        `Size:       ${block.size ?? '—'} bytes`,
        `Weight:     ${block.weight ?? '—'} wu`,
        `Version:    ${block.version ?? '—'} (0x${block.version != null ? block.version.toString(16) : '—'})`,
        `Merkle:     ${block.merkle_root ?? '—'}`,
        `Difficulty: ${block.difficulty ?? '—'}`,
        `Bits:       ${block.bits ?? '—'}`,
        `Nonce:      ${block.nonce ?? '—'} (0x${block.nonce != null ? block.nonce.toString(16) : '—'})`,
        `Prev:       ${block.previousblockhash ?? '—'}`,
        `Median:     ${block.mediantime ? new Date(block.mediantime * 1000).toISOString() + ' (' + block.mediantime + ')' : '—'}`,
        coinbaseAscii ? `Coinbase:   "${coinbaseAscii.slice(0, 120)}${coinbaseAscii.length > 120 ? '…' : ''}"` : `Coinbase:   —`,
      ];
      infoEl.textContent = lines.join('\n');
      updateAgePill(block);

      const hashForLink = block.id ?? block.hash;
      if (sourceLink) {
        sourceLink.href = hashForLink
          ? `https://mempool.space/block/${hashForLink}`
          : 'https://mempool.space/';
      }
    }

    function assignPoolsFromData(data) {
      if (!data) return;
      const headerCols = Math.max(1, Math.floor(columns * CONFIG.headerColumnPercentage));
      
      for (let i = 0; i < columns; i++) {
        let pool = '';
        let poolColors = [];
        let hue = CONFIG.primaryColor;
        
        if (i < headerCols) {
          // Left: Block header data - no gold
          pool = data.headerData || '';
          poolColors = Array(pool.length).fill(false);
          hue = CONFIG.primaryColor;
        } else {
          // Right: UTXO data with gradient - mark bitcoin amounts as gold
          pool = data.utxoData || '';
          poolColors = Array(pool.length).fill(false);
          // Find bitcoin symbols and mark them + following digits as gold
          for (let j = 0; j < pool.length; j++) {
            if (pool[j] === '₿') {
              poolColors[j] = true;
              // Mark following digits and decimal point as gold
              for (let k = j + 1; k < pool.length; k++) {
                const ch = pool[k];
                if ((ch >= '0' && ch <= '9') || ch === '.') {
                  poolColors[k] = true;
                } else {
                  break; // Stop at first non-digit/non-decimal
                }
              }
            }
          }
          // Use uniform color for consistent brightness across screen
          hue = CONFIG.primaryColor;
        }
        if (!pool || !pool.length) {
          pool = '0123456789abcdef';
          poolColors = Array(pool.length).fill(false);
        }
        columnPools[i] = pool;
        columnPoolColors[i] = poolColors;
        columnIndex[i] = Math.floor(Math.random() * pool.length);
        columnHue[i] = hue;
      }
      
      // Ensure trail lengths are initialized
      if (columnTrailLength.length !== columns) {
        const maxTrail = Math.floor(H / fontSize * CONFIG.trailLengthMaxPercent);
        columnTrailLength = Array(columns).fill(0).map(() => Math.floor(CONFIG.trailLengthMin + Math.random() * (maxTrail - CONFIG.trailLengthMin)));
      }
    }

    async function fetchLatestTipHash() {
      const res = await fetch(`${API_BASE}/blocks/tip/hash`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Tip hash fetch failed: ${res.status}`);
      return (await res.text()).trim();
    }
    async function fetchBlockByHash(hash) {
      const res = await fetch(`${API_BASE}/block/${hash}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Block fetch failed: ${res.status}`);
      return res.json();
    }
    async function fetchBlockTxids(hash) {
      const res = await fetch(`${API_BASE}/block/${hash}/txids`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Block txids fetch failed: ${res.status}`);
      return res.json();
    }
    async function fetchTx(txid) {
      const res = await fetch(`${API_BASE}/tx/${txid}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Tx fetch failed: ${res.status}`);
      return res.json();
    }

    async function refreshLatestBlock() {
      try {
        setStatus('Fetching latest block from mempool.space…');
        const tipHash = await fetchLatestTipHash();
        if (!tipHash || tipHash === lastHash) {
          updateAgePill(latestBlock);
          setStatus('No new block; overlay refreshed.');
          return;
        }

        const block = await fetchBlockByHash(tipHash);
        latestBlock = block;
        lastHash = tipHash;
        
        // Trigger transition effect for new block
        triggerTransition();

        let txids = [];
        try { txids = await fetchBlockTxids(tipHash); } catch {}
        const txCount = Array.isArray(txids) ? txids.length : (block.tx_count ?? undefined);

        let coinbaseAscii = '';
        if (Array.isArray(txids) && txids.length) {
          try {
            const coinbaseTx = await fetchTx(txids[0]);
            const vin0 = coinbaseTx?.vin?.[0];
            const cbHex = vin0?.coinbase || vin0?.scriptsig || vin0?.scriptSig || '';
            coinbaseAscii = hexToAsciiSafe(cbHex);
          } catch {}
        }

        // Prepare block header data
        const headerData = [
          block.id || block.hash || '',
          block.merkle_root || '',
          'version' + block.version,
          'bits' + block.bits,
          'nonce' + block.nonce,
          'difficulty' + block.difficulty,
          'timestamp' + block.timestamp,
          'height' + block.height,
          coinbaseAscii
        ].join(' ').toLowerCase().replace(/[^a-z0-9 ]/g, '');

        // Fetch UTXO data from configured number of transactions
        const utxoStrings = [];
        const txLimit = Math.min(CONFIG.transactionFetchLimit, txids.length);
        setStatus(`Fetching UTXO data (${txLimit} transactions)…`);
        
        for (let i = 0; i < txLimit; i++) {
          try {
            const tx = await fetchTx(txids[i]);
            // Extract outputs (UTXOs)
            if (tx.vout) {
              for (const out of tx.vout) {
                const addr = out.scriptpubkey_address || 'unknown';
                const sats = out.value || 0;
                const btc = (sats / 100000000).toFixed(8);
                utxoStrings.push(`${addr} ₿${btc} ${tx.txid}`);
              }
            }
            // Extract inputs (previous outputs being spent)
            if (tx.vin) {
              for (const inp of tx.vin) {
                if (inp.prevout) {
                  const addr = inp.prevout.scriptpubkey_address || 'unknown';
                  const sats = inp.prevout.value || 0;
                  const btc = (sats / 100000000).toFixed(8);
                  utxoStrings.push(`${addr} ₿${btc} ${tx.txid}`);
                }
              }
            }
          } catch (e) {
            console.warn(`Failed to fetch tx ${txids[i]}:`, e);
          }
        }

        const utxoData = utxoStrings.join(' ').toLowerCase().replace(/[^a-z0-9₿. ]/g, '');
        
        const data = { headerData, utxoData };
        latestGlyphs = data;
        assignPoolsFromData(data);

        renderOverlay(block, txCount, coinbaseAscii);
        setStatus(`Updated to block ${block.height} (${tipHash.slice(0, 12)}…)`);
      } catch (e) {
        infoEl.textContent = `Error fetching from mempool.space: ${e.message}`;
        setStatus('Connection error; retrying soon…');
      }
    }

    // ===== Initialize Application =====
    async function initApp() {
      CONFIG = await loadConfig();
      fontSize = CONFIG.fontSize;
      API_BASE = CONFIG.apiBase;
      
      // Initialize matrix after config is loaded
      initColumns();
      drawMatrix();
      
      // Apply UI visibility settings
      applyUIVisibility();
      
      // Start block updates
      refreshLatestBlock();
      setInterval(refreshLatestBlock, CONFIG.blockRefreshInterval);
      setInterval(() => updateAgePill(latestBlock), CONFIG.ageUpdateInterval);
    }

    // Start the application
    initApp();
  </script>
</body>
</html>
