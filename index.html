
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bitcoin Block – Data-Driven Matrix (mempool.space)</title>
  <style>
    :root {
      --matrix-green: #00ff7f;
      --matrix-dim: #00aa55;
      --matrix-deep: #008844;
      --bg-black: #000000;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --panel-bg: rgba(0, 0, 0, 0.6);
    }
    html, body {
      width: 100%; height: 100%;
      margin: 0; background: var(--bg-black);
      color: var(--matrix-green);
      font-family: var(--mono);
      overflow: hidden;
    }
    #canvas { position: fixed; inset: 0; display: block; background: #000; }
    #overlay {
      position: fixed; top: 1rem; left: 1rem;
      background: var(--panel-bg); border: 1px solid var(--matrix-dim);
      padding: 0.75rem 1rem; border-radius: 6px; backdrop-filter: blur(2px);
      box-shadow: 0 0 12px rgba(0,255,127,0.2); max-width: min(92vw, 56rem);
      cursor: pointer; transition: all 0.3s ease;
    }
    #overlay:hover { box-shadow: 0 0 18px rgba(0,255,127,0.35); }
    #overlay h1 {
      margin: 0 0 0.5rem 0; font-size: 1rem; letter-spacing: 0.08em;
      color: var(--matrix-green); text-shadow: 0 0 6px rgba(0,255,127,0.35);
      display: flex; align-items: center; gap: .5rem; flex-wrap: wrap;
    }
    #toggle-icon {
      margin-left: auto; font-size: 1.2rem; transition: transform 0.3s ease;
      user-select: none;
    }
    #overlay.collapsed #toggle-icon { transform: rotate(-90deg); }
    #overlay.collapsed #block-info,
    #overlay.collapsed #legend {
      max-height: 0; overflow: hidden; opacity: 0;
      margin: 0; transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    }
    #block-info, #legend {
      max-height: 1000px; opacity: 1;
      transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    }
    .pill {
      border: 1px solid var(--matrix-dim); border-radius: 999px;
      padding: 0.1rem 0.5rem; font-size: 0.85rem; color: var(--matrix-green);
    }
    #overlay pre { margin: 0.25rem 0 0 0; white-space: pre-wrap; word-break: break-all; color: var(--matrix-dim); line-height: 1.25; }
    #legend { margin-top: .5rem; color: var(--matrix-deep); font-size: .85rem; }
    #status {
      position: fixed; right: 1rem; bottom: 1rem;
      color: var(--matrix-dim); font-size: 0.8rem;
      background: var(--panel-bg); padding: .35rem .5rem; border-radius: 4px;
      border: 1px solid var(--matrix-dim);
    }
    a { color: var(--matrix-green); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .hidden-ui { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
    
    /* Menu Bar Styles */
    #menu-bar {
      position: fixed; top: 0; left: 0; right: 0;
      background: rgba(0, 0, 0, 0.85); border-bottom: 2px solid var(--matrix-green);
      padding: 0.75rem 1.5rem; font-family: var(--mono);
      display: flex; gap: 2rem; align-items: center;
      box-shadow: 0 0 20px rgba(0, 255, 127, 0.3);
      z-index: 100; transition: transform 0.3s ease;
    }
    #menu-bar.hidden { transform: translateY(-100%); }
    .menu-item {
      color: var(--matrix-green); cursor: pointer; font-size: 1rem;
      letter-spacing: 0.05em; transition: all 0.2s ease;
      text-shadow: 0 0 5px rgba(0, 255, 127, 0.5);
    }
    .menu-item:hover {
      color: var(--matrix-green); text-shadow: 0 0 10px rgba(0, 255, 127, 0.8);
      transform: translateY(-1px);
    }
    .menu-item u { text-decoration: underline; text-underline-offset: 3px; }
    
    /* Panel Overlay Styles */
    #panel-overlay {
      position: fixed; inset: 0; background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px); z-index: 200;
      display: flex; align-items: center; justify-content: center;
      transition: opacity 0.3s ease;
    }
    #panel-overlay.hidden { opacity: 0; pointer-events: none; }
    #panel-container {
      width: 70%; max-width: 1200px; max-height: 80vh;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid var(--matrix-green);
      box-shadow: 0 0 30px rgba(0, 255, 127, 0.4), inset 0 0 30px rgba(0, 255, 127, 0.05);
      font-family: var(--mono); color: var(--matrix-green);
      display: flex; flex-direction: column;
      animation: panelSlideIn 0.3s ease;
    }
    @keyframes panelSlideIn {
      from { transform: translateY(-20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    #panel-header {
      padding: 1rem 1.5rem; border-bottom: 1px solid var(--matrix-dim);
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0, 255, 127, 0.05);
    }
    #panel-title {
      font-size: 1.2rem; font-weight: bold; letter-spacing: 0.1em;
      text-transform: uppercase; text-shadow: 0 0 8px rgba(0, 255, 127, 0.6);
    }
    #panel-close {
      cursor: pointer; font-size: 1.5rem; line-height: 1;
      transition: all 0.2s ease; opacity: 0.7;
    }
    #panel-close:hover {
      opacity: 1; transform: scale(1.2);
      text-shadow: 0 0 10px rgba(0, 255, 127, 0.8);
    }
    #panel-content {
      padding: 1.5rem; overflow-y: auto; flex: 1;
      line-height: 1.6;
    }
    #panel-content::-webkit-scrollbar { width: 8px; }
    #panel-content::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.5); }
    #panel-content::-webkit-scrollbar-thumb {
      background: var(--matrix-dim); border-radius: 4px;
    }
    #panel-content::-webkit-scrollbar-thumb:hover { background: var(--matrix-green); }
    
    .panel-section { margin-bottom: 1.5rem; }
    .panel-section-title {
      font-size: 1rem; font-weight: bold; margin-bottom: 0.5rem;
      color: var(--matrix-green); text-transform: uppercase;
      letter-spacing: 0.08em; border-bottom: 1px solid var(--matrix-dim);
      padding-bottom: 0.3rem;
    }
    .panel-data-row {
      display: flex; padding: 0.3rem 0; gap: 1rem;
    }
    .panel-data-label {
      color: var(--matrix-dim); min-width: 150px;
    }
    .panel-data-value {
      color: var(--matrix-green); word-break: break-all; flex: 1;
    }
    
    /* Node Monitor Styles */
    .node-status-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 1.5rem; padding-bottom: 0.75rem;
      border-bottom: 2px solid var(--matrix-dim);
    }
    .node-hostname {
      font-size: 1.1rem; font-weight: bold;
      color: var(--matrix-green); text-shadow: 0 0 8px rgba(0, 255, 127, 0.5);
    }
    .node-timestamp {
      font-size: 0.85rem; display: flex; align-items: center; gap: 0.5rem;
    }
    .staleness-indicator {
      width: 12px; height: 12px; border-radius: 50%;
      display: inline-block; box-shadow: 0 0 8px currentColor;
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .staleness-green { background: #00ff00; color: #00ff00; }
    .staleness-yellow { background: #ffff00; color: #ffff00; }
    .staleness-red { background: #ff0000; color: #ff0000; }
    
    .service-group {
      margin-bottom: 1.5rem;
      border: 1px solid var(--matrix-dim);
      border-radius: 4px;
      padding: 1rem;
      background: rgba(0, 255, 127, 0.02);
    }
    .service-group-title {
      font-size: 1rem;
      font-weight: bold;
      color: var(--matrix-green);
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border-bottom: 1px solid var(--matrix-dim);
      padding-bottom: 0.3rem;
    }
    .check-item {
      padding: 0.5rem;
      margin: 0.5rem 0;
      border-left: 3px solid var(--matrix-dim);
      background: rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    .check-item:hover {
      background: rgba(0, 255, 127, 0.05);
      border-left-color: var(--matrix-green);
    }
    .check-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.3rem;
    }
    .status-badge {
      padding: 0.15rem 0.5rem;
      border-radius: 3px;
      font-size: 0.75rem;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      box-shadow: 0 0 8px currentColor;
    }
    .status-OK {
      background: rgba(0, 255, 0, 0.2);
      color: #00ff00;
      border: 1px solid #00ff00;
    }
    .status-WARN {
      background: rgba(255, 255, 0, 0.2);
      color: #ffff00;
      border: 1px solid #ffff00;
    }
    .status-ERROR {
      background: rgba(255, 0, 0, 0.2);
      color: #ff0000;
      border: 1px solid #ff0000;
    }
    .check-name {
      flex: 1;
      color: var(--matrix-green);
      font-weight: bold;
    }
    .check-message {
      color: var(--matrix-dim);
      font-size: 0.85rem;
      margin-left: 0.75rem;
    }
    .check-metrics {
      margin-left: 0.75rem;
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 3px;
      font-size: 0.8rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.5rem;
    }
    .metric-item {
      color: var(--matrix-dim);
    }
    .metric-label {
      color: var(--matrix-deep);
    }
    .metric-value {
      color: var(--matrix-green);
      font-weight: bold;
    }
    
    .glitch-effect {
      animation: glitch 0.3s ease;
    }
    @keyframes glitch {
      0%, 100% { transform: translate(0); opacity: 1; }
      10% { transform: translate(-2px, 2px); opacity: 0.8; }
      20% { transform: translate(2px, -2px); opacity: 0.9; }
      30% { transform: translate(-2px, -2px); opacity: 0.7; }
      40% { transform: translate(2px, 2px); opacity: 0.9; }
      50% { transform: translate(-1px, 1px); opacity: 0.85; }
      60% { transform: translate(1px, -1px); opacity: 0.95; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="overlay" class="collapsed hidden-ui">
    <h1>
      Latest Block ▮ Bitcoin <span class="pill">main</span>
      <span id="height" class="pill">Height: —</span>
      <span id="age" class="pill">Age: —</span>
      <span id="txcount" class="pill">Tx: —</span>
      <span id="source" class="pill">https://mempool.space/mempool.space</a></span>
      <span id="toggle-icon">▼</span>
    </h1>
    <pre id="block-info">Loading…</pre>
    <div id="legend">⬅︎ Block Header (left ~25%) • UTXO Data: addresses, amounts ₿, hashes (right ~75%)</div>
  </div>

  <div id="status" class="hidden-ui">Matrix connected to mempool.space…</div>

  <!-- Menu Bar -->
  <div id="menu-bar" class="hidden">
    <span class="menu-item" data-key="b" data-panel="blockDetails"><u>B</u>lock Details</span>
    <span class="menu-item" data-key="n" data-panel="nodeMonitor"><u>N</u>ode Monitor</span>
  </div>

  <!-- Panel Overlay -->
  <div id="panel-overlay" class="hidden">
    <div id="panel-container">
      <div id="panel-header">
        <span id="panel-title"></span>
        <span id="panel-close">✕</span>
      </div>
      <div id="panel-content"></div>
    </div>
  </div>

  <script>
    // ===== CONFIGURATION LOADING =====
    let CONFIG = null;
    
    async function loadConfig() {
      try {
        const response = await fetch('config.json');
        if (!response.ok) throw new Error('Config file not found');
        const config = await response.json();
        
        // Flatten the nested structure for easier access
        return {
          // Display Layout
          headerColumnPercentage: config.display.headerColumnPercentage,
          showUIOnLoad: config.display.showUIOnLoad,
          initiallyCollapsed: config.display.initiallyCollapsed,
          
          // Matrix Visual Settings
          fontSize: config.matrix.fontSize,
          matrixSpeed: config.matrix.matrixSpeed,
          trailLengthMin: config.matrix.trailLengthMin,
          trailLengthMaxPercent: config.matrix.trailLengthMaxPercent,
          fadeStartOpacity: config.matrix.fadeStartOpacity,
          fadeExponent: config.matrix.fadeExponent,
          backgroundFadeAlpha: config.matrix.backgroundFadeAlpha,
          resetProbability: config.matrix.resetProbability,
          headCycleFrames: config.matrix.headCycleFrames || 8,
          headCycleChars: config.matrix.headCycleChars || 'abcdefghijklmnopqrstuvwxyz0123456789',
          enableBackgroundLayer: config.matrix.enableBackgroundLayer !== false,
          backgroundLayerOpacity: config.matrix.backgroundLayerOpacity || 0.35,
          backgroundLayerSpeed: config.matrix.backgroundLayerSpeed || 0.4,
          
          // Colors
          primaryColor: config.colors.primaryColor,
          goldColor: config.colors.goldColor,
          cyclingColor: config.colors.cyclingColor || '#00ffff',
          gradientStartRGB: config.colors.gradientStartRGB,
          gradientEndRGB: config.colors.gradientEndRGB,
          
          // API Settings
          apiBase: config.api.apiBase,
          blockRefreshInterval: config.api.blockRefreshInterval,
          ageUpdateInterval: config.api.ageUpdateInterval,
          transactionFetchLimit: config.api.transactionFetchLimit,
          
          // Keyboard
          toggleKey: config.keyboard.toggleKey,
          
          // Transitions
          transitionEffect: config.transitions?.effectType || 'none',
          glitchDuration: config.transitions?.glitchDuration || 300,
          glitchIntensity: config.transitions?.glitchIntensity || 0.15,
        };
      } catch (error) {
        console.error('Failed to load config, using defaults:', error);
        // Return default configuration
        return {
          headerColumnPercentage: 0.25,
          showUIOnLoad: false,
          initiallyCollapsed: true,
          fontSize: 18,
          matrixSpeed: 0.5,
          trailLengthMin: 5,
          trailLengthMaxPercent: 0.8,
          fadeStartOpacity: 0.5,
          fadeExponent: 2,
          backgroundFadeAlpha: 0.15,
          resetProbability: 0.975,
          headCycleFrames: 8,
          headCycleChars: 'abcdefghijklmnopqrstuvwxyz0123456789',
          enableBackgroundLayer: true,
          backgroundLayerOpacity: 0.35,
          backgroundLayerSpeed: 0.4,
          primaryColor: '#00ff7f',
          goldColor: '#FFD700',
          cyclingColor: '#00ffff',
          gradientStartRGB: [0, 170, 85],
          gradientEndRGB: [0, 136, 68],
          apiBase: 'https://mempool.space/api',
          blockRefreshInterval: 30000,
          ageUpdateInterval: 1000,
          transactionFetchLimit: 15,
          toggleKey: 's',
          transitionEffect: 'none',
          glitchDuration: 300,
          glitchIntensity: 0.15,
        };
      }
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let W = window.innerWidth, H = window.innerHeight;
    let fontSize = 18; // Will be updated from config
    canvas.width = W; canvas.height = H;

    let columns = Math.floor(W / fontSize);
    let drops = [];
    let columnPools = [];
    let columnPoolColors = []; // Track which characters in pool should be gold
    let columnIndex = [];
    let columnHue = [];
    let columnTrailLength = [];
    let columnChars = []; // Current character for each column
    let columnLastPos = []; // Track last integer position
    let columnCharHistory = []; // History buffer for trailing characters
    let columnColorHistory = []; // Color history for each character
    let columnCycleFrames = []; // Remaining frames to cycle head character
    let columnActualChar = []; // The actual character to display after cycling
    
    // ===== BACKGROUND LAYER (for depth) =====
    let bgDrops = [];
    let bgChars = [];
    let bgLastPos = [];
    let bgTrailLength = [];
    let bgCharHistory = [];
    let bgColorHistory = []; // Track gold colors in background
    let bgIndex = []; // Track position in pool
    
    // ===== TRANSITION EFFECTS =====
    let transitionActive = false;
    let transitionStartTime = 0;
    let glitchOriginalPools = [];
    let glitchOriginalIndices = [];

    function triggerTransition() {
      if (!CONFIG || CONFIG.transitionEffect === 'none') return;
      
      transitionActive = true;
      transitionStartTime = Date.now();
      
      // Prepare effect-specific data
      if (CONFIG.transitionEffect === 'glitch') {
        // Store original state
        glitchOriginalPools = columnPools.map(p => p);
        glitchOriginalIndices = columnIndex.map(i => i);
      }
    }
    
    function applyGlitchEffect() {
      const elapsed = Date.now() - transitionStartTime;
      const duration = CONFIG.glitchDuration;
      
      if (elapsed >= duration) {
        // Restore original state
        transitionActive = false;
        return;
      }
      
      // Randomly scramble characters based on intensity
      const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?/~`';
      for (let i = 0; i < columns; i++) {
        if (Math.random() < CONFIG.glitchIntensity) {
          // Scramble this column's character
          if (Math.random() < 0.5) {
            // Use random glitch character
            columnChars[i] = glitchChars[Math.floor(Math.random() * glitchChars.length)];
          } else {
            // Use random character from a different column's pool
            const randomCol = Math.floor(Math.random() * columns);
            const randomPool = columnPools[randomCol] || glitchChars;
            columnChars[i] = randomPool[Math.floor(Math.random() * randomPool.length)];
          }
        }
      }
    }
    
    function updateTransition() {
      if (!transitionActive) return;
      
      switch (CONFIG.transitionEffect) {
        case 'glitch':
          applyGlitchEffect();
          break;
        // Future effects can be added here:
        // case 'cascade': applyCascadeEffect(); break;
        // case 'flash': applyFlashEffect(); break;
      }
    }

    function initColumns() {
      if (!CONFIG) return; // Wait for config to load
      
      columns = Math.floor(W / fontSize);
      drops = Array(columns).fill(0).map(() => Math.random() * H / fontSize);
      columnPools = Array(columns).fill('');
      columnPoolColors = Array(columns).fill(null).map(() => []);
      columnIndex = Array(columns).fill(0);
      columnHue = Array(columns).fill(CONFIG.primaryColor);
      const maxTrail = Math.floor(H / fontSize * CONFIG.trailLengthMaxPercent);
      columnTrailLength = Array(columns).fill(0).map(() => Math.floor(CONFIG.trailLengthMin + Math.random() * (maxTrail - CONFIG.trailLengthMin)));
      columnChars = Array(columns).fill('');
      columnLastPos = Array(columns).fill(-1);
      columnCharHistory = Array(columns).fill(null).map(() => []);
      columnColorHistory = Array(columns).fill(null).map(() => []);
      columnCycleFrames = Array(columns).fill(0);
      columnActualChar = Array(columns).fill('');
      
      // Initialize background layer streams (between main columns)
      if (CONFIG.enableBackgroundLayer) {
        bgDrops = Array(columns).fill(0).map(() => Math.random() * H / fontSize);
        bgChars = Array(columns).fill('');
        bgLastPos = Array(columns).fill(-1);
        const maxTrailBg = Math.floor(H / fontSize * CONFIG.trailLengthMaxPercent * 0.8); // Slightly shorter
        bgTrailLength = Array(columns).fill(0).map(() => Math.floor(CONFIG.trailLengthMin + Math.random() * (maxTrailBg - CONFIG.trailLengthMin)));
        bgCharHistory = Array(columns).fill(null).map(() => []);
        bgColorHistory = Array(columns).fill(null).map(() => []);
        bgIndex = Array(columns).fill(0).map(() => Math.floor(Math.random() * 10));
      }
    }

    window.addEventListener('resize', () => {
      W = window.innerWidth; H = window.innerHeight;
      canvas.width = W; canvas.height = H;
      if (CONFIG) {
        initColumns();
        assignPoolsFromData(latestGlyphs);
      }
    });

    function nextGlyph(i) {
      const pool = columnPools[i] || '0123456789abcdef';
      if (!pool.length) return ' ';
      const ch = pool[columnIndex[i] % pool.length];
      columnIndex[i] = (columnIndex[i] + 1) % pool.length;
      return ch;
    }

    function drawMatrix() {
      // Update transition effects
      updateTransition();
      
      ctx.fillStyle = `rgba(0, 0, 0, ${CONFIG.backgroundFadeAlpha})`;
      ctx.fillRect(0, 0, W, H);
      ctx.font = `${fontSize}px monospace`;

      // ===== DRAW BACKGROUND LAYER (for depth) =====
      if (CONFIG.enableBackgroundLayer) {
        const headerCols = Math.max(1, Math.floor(columns * CONFIG.headerColumnPercentage));
        for (let i = 0; i < bgDrops.length; i++) {
          // Skip background layer in header columns for cleaner distinction
          if (i < headerCols) continue;
          
          const currentPos = Math.floor(bgDrops[i]);
          
          // Get new character when position changes
          if (currentPos !== bgLastPos[i]) {
            const pool = columnPools[i] || '0123456789abcdef';
            const poolColors = columnPoolColors[i] || [];
            const idx = bgIndex[i] % pool.length;
            bgChars[i] = pool[idx];
            const isGold = poolColors[idx] || false;
            bgIndex[i] = (bgIndex[i] + 1) % pool.length;
            bgLastPos[i] = currentPos;
            bgCharHistory[i].unshift(bgChars[i]);
            bgColorHistory[i].unshift(isGold);
            if (bgCharHistory[i].length > Math.floor(H / fontSize)) {
              bgCharHistory[i].length = Math.floor(H / fontSize);
              bgColorHistory[i].length = Math.floor(H / fontSize);
            }
          }
          
          const ch = bgChars[i];
          // Offset x position to fall between main columns
          const x = i * fontSize + fontSize * 0.5;
          const y = currentPos * fontSize;
          
          // Determine if this character should be gold
          const isGoldChar = bgColorHistory[i][0] || false;
          
          // Draw head at reduced opacity with appropriate color
          if (isGoldChar) {
            const goldHex = CONFIG.goldColor;
            const r = parseInt(goldHex.slice(1, 3), 16);
            const g = parseInt(goldHex.slice(3, 5), 16);
            const b = parseInt(goldHex.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${CONFIG.backgroundLayerOpacity})`;
          } else {
            const colorHex = CONFIG.primaryColor;
            const r = parseInt(colorHex.slice(1, 3), 16);
            const g = parseInt(colorHex.slice(3, 5), 16);
            const b = parseInt(colorHex.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${CONFIG.backgroundLayerOpacity})`;
          }
          ctx.fillText(ch, x, y);
          
          // Draw trail
          const trailLen = bgTrailLength[i];
          for (let j = 1; j <= trailLen; j++) {
            const trailY = y - (j * fontSize);
            if (trailY < -fontSize || trailY > H) continue;
            
            const fadeRatio = j / trailLen;
            const opacity = CONFIG.backgroundLayerOpacity * CONFIG.fadeStartOpacity * Math.pow(1 - fadeRatio, CONFIG.fadeExponent);
            
            if (opacity > 0.02) {
              const trailChar = bgCharHistory[i][j] || ch;
              const trailIsGold = bgColorHistory[i][j] || false;
              
              if (trailIsGold) {
                const goldHex = CONFIG.goldColor;
                const r = parseInt(goldHex.slice(1, 3), 16);
                const g = parseInt(goldHex.slice(3, 5), 16);
                const b = parseInt(goldHex.slice(5, 7), 16);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
              } else {
                const colorHex = CONFIG.primaryColor;
                const r = parseInt(colorHex.slice(1, 3), 16);
                const g = parseInt(colorHex.slice(3, 5), 16);
                const b = parseInt(colorHex.slice(5, 7), 16);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
              }
              ctx.fillText(trailChar, x, trailY);
            }
          }
          
          if (y > H && Math.random() > CONFIG.resetProbability) bgDrops[i] = 0;
          bgDrops[i] += CONFIG.backgroundLayerSpeed;
        }
      }

      // ===== DRAW PRIMARY LAYER =====
      for (let i = 0; i < drops.length; i++) {
        const currentPos = Math.floor(drops[i]);
        
        // Only get new character when position changes
        if (currentPos !== columnLastPos[i]) {
          columnActualChar[i] = nextGlyph(i);
          columnLastPos[i] = currentPos;
          // Start cycling animation at head
          columnCycleFrames[i] = CONFIG.headCycleFrames;
          
          // Get color from pool color array
          const poolColors = columnPoolColors[i];
          const idx = (columnIndex[i] - 1 + poolColors.length) % poolColors.length;
          const isGold = poolColors[idx] || false;
          
          // Immediately add to history with the actual character
          columnCharHistory[i].unshift(columnActualChar[i]);
          columnColorHistory[i].unshift(isGold);
          
          // Keep history buffer size manageable
          const maxHistory = Math.floor(H / fontSize);
          if (columnCharHistory[i].length > maxHistory) {
            columnCharHistory[i].length = maxHistory;
            columnColorHistory[i].length = maxHistory;
          }
        }
        
        // Handle head character cycling (only at current position)
        if (columnCycleFrames[i] > 0) {
          // Cycle through random characters from cycle pool
          const cyclePool = CONFIG.headCycleChars;
          columnChars[i] = cyclePool[Math.floor(Math.random() * cyclePool.length)];
          columnCycleFrames[i]--;
        } else {
          // Cycling complete, use actual character
          columnChars[i] = columnActualChar[i];
        }
        
        const ch = columnChars[i];
        const x = i * fontSize;
        const y = currentPos * fontSize;

        // Bright leading character (always at full brightness during cycling)
        if (columnCycleFrames[i] > 0) {
          // Cycling: use bright cyan color for emphasis
          ctx.fillStyle = CONFIG.cyclingColor;
        } else {
          // Normal: use appropriate color (gold for bitcoin amounts)
          const isGoldChar = columnColorHistory[i][0];
          ctx.fillStyle = isGoldChar ? CONFIG.goldColor : columnHue[i];
        }
        ctx.fillText(ch, x, y);

        // Draw variable length fading trail
        const baseHue = columnHue[i];
        let r, g, b;
        if (baseHue.startsWith('#')) {
          r = parseInt(baseHue.slice(1, 3), 16);
          g = parseInt(baseHue.slice(3, 5), 16);
          b = parseInt(baseHue.slice(5, 7), 16);
        } else if (baseHue.startsWith('rgb')) {
          const match = baseHue.match(/\d+/g);
          if (match) {
            r = parseInt(match[0]);
            g = parseInt(match[1]);
            b = parseInt(match[2]);
          } else {
            r = 0; g = 170; b = 85;
          }
        } else {
          r = 0; g = 170; b = 85;
        }
        
        // Draw trailing characters with exponential fade for readability
        const trailLen = columnTrailLength[i];
        const history = columnCharHistory[i];
        for (let j = 1; j <= trailLen; j++) {
          const trailY = y - (j * fontSize);
          if (trailY < -fontSize || trailY > H) continue;
          
          // Exponential fade with configurable parameters
          const fadeRatio = j / trailLen;
          const opacity = CONFIG.fadeStartOpacity * Math.pow(1 - fadeRatio, CONFIG.fadeExponent);
          
          if (opacity > 0.05) {
            // Use character from history if available, otherwise current char
            const trailChar = history[j] || ch;
            const trailIsGold = columnColorHistory[i][j];
            if (trailIsGold) {
              const [gr, gg, gb] = [255, 215, 0]; // Gold RGB
              ctx.fillStyle = `rgba(${gr}, ${gg}, ${gb}, ${opacity})`;
            } else {
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            ctx.fillText(trailChar, x, trailY);
          }
        }

        if (y > H && Math.random() > CONFIG.resetProbability) drops[i] = 0;
        drops[i] += CONFIG.matrixSpeed;
      }
      requestAnimationFrame(drawMatrix);
    }

    // ===== Initialize UI Visibility =====
    const overlayEl = document.getElementById('overlay');
    const statusEl = document.getElementById('status');
    
    function applyUIVisibility() {
      if (!CONFIG.showUIOnLoad) {
        // UI starts hidden (keep hidden-ui class)
      } else {
        // Show UI on load
        overlayEl.classList.remove('hidden-ui');
        statusEl.classList.remove('hidden-ui');
      }
      
      if (!CONFIG.initiallyCollapsed) {
        overlayEl.classList.remove('collapsed');
      }
    }

    // ===== Menu System =====
    const menuBar = document.getElementById('menu-bar');
    const panelOverlay = document.getElementById('panel-overlay');
    const panelTitle = document.getElementById('panel-title');
    const panelContent = document.getElementById('panel-content');
    const panelClose = document.getElementById('panel-close');
    
    let menuOpen = false;
    let panelOpen = false;
    let currentPanel = null;
    
    function openMenu() {
      menuBar.classList.remove('hidden');
      menuOpen = true;
    }
    
    function closeMenu() {
      menuBar.classList.add('hidden');
      menuOpen = false;
    }
    
    function openPanel(panelType) {
      currentPanel = panelType;
      panelOpen = true;
      panelOverlay.classList.remove('hidden');
      
      // Set panel title and content based on type
      switch(panelType) {
        case 'blockDetails':
          panelTitle.textContent = 'Block Details';
          renderBlockDetailsPanel();
          break;
        case 'nodeMonitor':
          panelTitle.textContent = 'Node Monitor';
          startNodeStatusRefresh();
          break;
      }
      
      closeMenu(); // Close menu when panel opens
    }
    
    function closePanel() {
      panelOverlay.classList.add('hidden');
      panelOpen = false;
      currentPanel = null;
      
      // Stop node status refresh when panel closes
      stopNodeStatusRefresh();
    }
    
    // ===== Panel Renderers =====
    function renderBlockDetailsPanel() {
      if (!latestBlock) {
        panelContent.innerHTML = '<div style="text-align: center; padding: 2rem;">No block data available</div>';
        return;
      }
      
      const block = latestBlock;
      const reward = (block.extras?.reward || 0) / 100000000;
      const fees = (block.extras?.totalFees || 0) / 100000000;
      const medianFee = block.extras?.medianFee || 0;
      const feeRange = block.extras?.feeRange || [];
      const avgFee = block.extras?.avgFee || 0;
      const utxoSetChange = block.extras?.utxoSetChange || 0;
      const avgFeeRate = block.extras?.avgFeeRate || 0;
      
      const timestamp = new Date(block.timestamp * 1000).toLocaleString();
      const difficulty = (block.difficulty / 1e12).toFixed(2) + 'T';
      
      panelContent.innerHTML = `
        <div class="panel-section">
          <div class="panel-section-title">Block Information</div>
          <div class="panel-data-row">
            <div class="panel-data-label">Height:</div>
            <div class="panel-data-value">${block.height}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Timestamp:</div>
            <div class="panel-data-value">${timestamp}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Transactions:</div>
            <div class="panel-data-value">${block.tx_count}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Size:</div>
            <div class="panel-data-value">${(block.size / 1024 / 1024).toFixed(2)} MB (${(block.weight / 4000000 * 100).toFixed(1)}% full)</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Weight:</div>
            <div class="panel-data-value">${block.weight.toLocaleString()} WU</div>
          </div>
        </div>
        
        <div class="panel-section">
          <div class="panel-section-title">Block Hashes</div>
          <div class="panel-data-row">
            <div class="panel-data-label">Hash:</div>
            <div class="panel-data-value" style="font-size: 0.85rem;">${block.id}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Previous Block:</div>
            <div class="panel-data-value" style="font-size: 0.85rem;">${block.previousblockhash}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Merkle Root:</div>
            <div class="panel-data-value" style="font-size: 0.85rem;">${block.merkle_root}</div>
          </div>
        </div>
        
        <div class="panel-section">
          <div class="panel-section-title">Mining Details</div>
          <div class="panel-data-row">
            <div class="panel-data-label">Difficulty:</div>
            <div class="panel-data-value">${difficulty}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Nonce:</div>
            <div class="panel-data-value">${block.nonce}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Version:</div>
            <div class="panel-data-value">0x${block.version.toString(16)}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Bits:</div>
            <div class="panel-data-value">${block.bits}</div>
          </div>
        </div>
        
        <div class="panel-section">
          <div class="panel-section-title">Fee Statistics</div>
          <div class="panel-data-row">
            <div class="panel-data-label">Block Reward:</div>
            <div class="panel-data-value" style="color: #FFD700;">₿${reward.toFixed(8)}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Total Fees:</div>
            <div class="panel-data-value" style="color: #FFD700;">₿${fees.toFixed(8)}</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Avg Fee Rate:</div>
            <div class="panel-data-value">${avgFeeRate} sat/vB</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Median Fee:</div>
            <div class="panel-data-value">${medianFee} sat</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">Fee Range:</div>
            <div class="panel-data-value">${feeRange.join(' - ')} sat/vB</div>
          </div>
          <div class="panel-data-row">
            <div class="panel-data-label">UTXO Set Change:</div>
            <div class="panel-data-value">${utxoSetChange > 0 ? '+' : ''}${utxoSetChange}</div>
          </div>
        </div>
      `;
    }
    
    // Node Monitor State
    let nodeStatusData = null;
    let nodeStatusInterval = null;
    
    function calculateStaleness(timestamp) {
      if (!timestamp) return 'red';
      const now = new Date();
      const updated = new Date(timestamp);
      const minutesAgo = (now - updated) / 1000 / 60;
      
      if (minutesAgo < 8) return 'green';
      if (minutesAgo < 15) return 'yellow';
      return 'red';
    }
    
    function formatTimestamp(timestamp) {
      if (!timestamp) return 'Unknown';
      const date = new Date(timestamp);
      const now = new Date();
      const secondsAgo = Math.floor((now - date) / 1000);
      
      if (secondsAgo < 60) return `${secondsAgo}s ago`;
      if (secondsAgo < 3600) return `${Math.floor(secondsAgo / 60)}m ago`;
      if (secondsAgo < 86400) return `${Math.floor(secondsAgo / 3600)}h ago`;
      return date.toLocaleString();
    }
    
    function renderMetrics(metrics) {
      if (!metrics || typeof metrics !== 'object') return '';
      
      return Object.entries(metrics)
        .map(([key, value]) => {
          let displayValue = value;
          if (typeof value === 'boolean') {
            displayValue = value ? 'Yes' : 'No';
          } else if (typeof value === 'object') {
            displayValue = JSON.stringify(value);
          }
          
          return `
            <div class="metric-item">
              <span class="metric-label">${key.replace(/_/g, ' ')}:</span>
              <span class="metric-value">${displayValue}</span>
            </div>
          `;
        })
        .join('');
    }
    
    function renderCheckItem(checkName, check) {
      const status = check.status || 'UNKNOWN';
      const message = check.message || 'No message';
      const metrics = check.metrics || {};
      
      return `
        <div class="check-item">
          <div class="check-header">
            <span class="status-badge status-${status}">${status}</span>
            <span class="check-name">${checkName.replace(/_/g, ' ').toUpperCase()}</span>
          </div>
          <div class="check-message">${message}</div>
          ${Object.keys(metrics).length > 0 ? `
            <div class="check-metrics">
              ${renderMetrics(metrics)}
            </div>
          ` : ''}
        </div>
      `;
    }
    
    function groupChecks(checks) {
      const groups = {
        'Bitcoin Core': [],
        'Lightning Network (LND)': [],
        'Tor Network': [],
        'Electrs': []
      };
      
      for (const [name, check] of Object.entries(checks)) {
        if (name.startsWith('bitcoin_')) {
          groups['Bitcoin Core'].push({ name, check });
        } else if (name.startsWith('lnd_')) {
          groups['Lightning Network (LND)'].push({ name, check });
        } else if (name.startsWith('tor_')) {
          groups['Tor Network'].push({ name, check });
        } else if (name.startsWith('electrs_')) {
          groups['Electrs'].push({ name, check });
        }
      }
      
      return groups;
    }
    
    async function fetchNodeStatus() {
      try {
        const response = await fetch('./status/status.json', { cache: 'no-store' });
        if (!response.ok) throw new Error('Failed to fetch status');
        const data = await response.json();
        
        // Apply glitch effect if data changed
        if (nodeStatusData && JSON.stringify(nodeStatusData) !== JSON.stringify(data)) {
          const content = panelContent;
          content.classList.add('glitch-effect');
          setTimeout(() => content.classList.remove('glitch-effect'), 300);
        }
        
        nodeStatusData = data;
        renderNodeMonitorPanel();
      } catch (error) {
        console.error('Error fetching node status:', error);
        panelContent.innerHTML = `
          <div style="padding: 2rem; text-align: center; color: var(--matrix-dim);">
            <p style="font-size: 1.2rem; margin-bottom: 1rem;">⚠ Unable to load node status</p>
            <p style="font-size: 0.9rem;">${error.message}</p>
            <p style="font-size: 0.8rem; margin-top: 1rem;">
              Expected file: ./status/status.json
            </p>
          </div>
        `;
      }
    }
    
    function renderNodeMonitorPanel() {
      if (!nodeStatusData) {
        panelContent.innerHTML = `
          <div style="padding: 2rem; text-align: center; color: var(--matrix-dim);">
            Loading node status...
          </div>
        `;
        return;
      }
      
      const staleness = calculateStaleness(nodeStatusData.timestamp);
      const groups = groupChecks(nodeStatusData.checks || {});
      
      let html = `
        <div class="node-status-header">
          <div class="node-hostname">
            ${nodeStatusData.hostname || 'Unknown Node'}
            ${nodeStatusData.node ? `<span style="color: var(--matrix-dim); font-size: 0.85rem; margin-left: 0.5rem;">(${nodeStatusData.node})</span>` : ''}
          </div>
          <div class="node-timestamp">
            <span class="staleness-indicator staleness-${staleness}"></span>
            <span>Last updated: ${formatTimestamp(nodeStatusData.timestamp)}</span>
          </div>
        </div>
      `;
      
      for (const [groupName, items] of Object.entries(groups)) {
        if (items.length === 0) continue;
        
        html += `
          <div class="service-group">
            <div class="service-group-title">${groupName}</div>
            ${items.map(({ name, check }) => renderCheckItem(name, check)).join('')}
          </div>
        `;
      }
      
      panelContent.innerHTML = html;
    }
    
    // Start periodic refresh when node monitor panel is opened
    function startNodeStatusRefresh() {
      if (nodeStatusInterval) return;
      fetchNodeStatus(); // Initial fetch
      nodeStatusInterval = setInterval(fetchNodeStatus, 30000); // Refresh every 30 seconds
    }
    
    function stopNodeStatusRefresh() {
      if (nodeStatusInterval) {
        clearInterval(nodeStatusInterval);
        nodeStatusInterval = null;
      }
    }
    
    // Panel close button handler
    panelClose.addEventListener('click', closePanel);
    
    // Click outside panel to close
    panelOverlay.addEventListener('click', (e) => {
      if (e.target === panelOverlay) closePanel();
    });

    // ===== Keyboard Controls =====
    window.addEventListener('keydown', (e) => {
      if (!CONFIG) return;
      const key = e.key.toLowerCase();
      
      // ESC key handling (still available as alternative)
      if (key === 'escape') {
        if (panelOpen) {
          closePanel();
        } else if (menuOpen) {
          closeMenu();
        }
        return;
      }
      
      // "/" key navigation - acts as back/toggle
      if (e.key === '/') {
        e.preventDefault();
        if (panelOpen) {
          // Panel is open: close panel and return to menu
          closePanel();
          openMenu();
        } else if (menuOpen) {
          // Menu is open: close menu
          closeMenu();
        } else {
          // Nothing open: open menu
          openMenu();
        }
        return;
      }
      
      // Menu item selection (when menu is open)
      if (menuOpen && !panelOpen) {
        const menuItems = document.querySelectorAll('.menu-item');
        for (const item of menuItems) {
          if (item.dataset.key === key) {
            openPanel(item.dataset.panel);
            return;
          }
        }
      }
      
      // Original toggle key for UI visibility
      if (key === CONFIG.toggleKey.toLowerCase()) {
        overlayEl.classList.toggle('hidden-ui');
        statusEl.classList.toggle('hidden-ui');
      }
    });

    // ===== Expandable Header =====
    overlayEl.addEventListener('click', () => {
      overlayEl.classList.toggle('collapsed');
    });

    // ===== Live Data =====
    const heightPill = document.getElementById('height');
    const agePill = document.getElementById('age');
    const txPill = document.getElementById('txcount');
    const infoEl = document.getElementById('block-info');
    const sourceLink = document.getElementById('sourceLink');

    let API_BASE = 'https://mempool.space/api';
    let lastHash = null;
    let latestBlock = null;
    let latestGlyphs = null;

    function setStatus(msg) { statusEl.textContent = msg; }
    function toLowerStr(val) { return (val ?? '') === '' ? '' : String(val).toLowerCase(); }
    function toHexStr(val) {
      if (val === undefined || val === null) return '';
      if (typeof val === 'string') return val.toLowerCase();
      if (typeof val === 'number') { try { return (val >>> 0).toString(16); } catch { return String(val); } }
      return String(val).toLowerCase();
    }
    function hexToAsciiSafe(hex) {
      if (!hex || typeof hex !== 'string') return '';
      const cleaned = hex.replace(/[^0-9a-fA-F]/g, '');
      let out = '';
      for (let i = 0; i < cleaned.length; i += 2) {
        const b = parseInt(cleaned.slice(i, i + 2), 16);
        if (!isNaN(b)) {
          const ch = String.fromCharCode(b);
          if (ch >= ' ' && ch <= '~') out += ch;
        }
      }
      return out.toLowerCase();
    }
    function updateAgePill(block) {
      if (!block || !block.timestamp) { agePill.textContent = 'Age: —'; return; }
      const secs = Math.max(0, Math.floor(Date.now()/1000) - block.timestamp);
      const mins = Math.floor(secs / 60);
      const rem = secs % 60;
      agePill.textContent = `Age: ${mins}m ${rem}s`;
    }

    function renderOverlay(block, txCount, coinbaseAscii) {
      heightPill.textContent = `Height: ${block.height ?? '—'}`;
      txPill.textContent = `Tx: ${txCount ?? '—'}`;

      const lines = [
        `Hash:       ${block.id ?? block.hash ?? '—'}`,
        `Time:       ${block.timestamp ? new Date(block.timestamp * 1000).toISOString() + ' (' + block.timestamp + ')' : '—'}`,
        `Tx Count:   ${txCount ?? '—'}`,
        `Size:       ${block.size ?? '—'} bytes`,
        `Weight:     ${block.weight ?? '—'} wu`,
        `Version:    ${block.version ?? '—'} (0x${block.version != null ? block.version.toString(16) : '—'})`,
        `Merkle:     ${block.merkle_root ?? '—'}`,
        `Difficulty: ${block.difficulty ?? '—'}`,
        `Bits:       ${block.bits ?? '—'}`,
        `Nonce:      ${block.nonce ?? '—'} (0x${block.nonce != null ? block.nonce.toString(16) : '—'})`,
        `Prev:       ${block.previousblockhash ?? '—'}`,
        `Median:     ${block.mediantime ? new Date(block.mediantime * 1000).toISOString() + ' (' + block.mediantime + ')' : '—'}`,
        coinbaseAscii ? `Coinbase:   "${coinbaseAscii.slice(0, 120)}${coinbaseAscii.length > 120 ? '…' : ''}"` : `Coinbase:   —`,
      ];
      infoEl.textContent = lines.join('\n');
      updateAgePill(block);

      const hashForLink = block.id ?? block.hash;
      if (sourceLink) {
        sourceLink.href = hashForLink
          ? `https://mempool.space/block/${hashForLink}`
          : 'https://mempool.space/';
      }
    }

    function assignPoolsFromData(data) {
      if (!data) return;
      const headerCols = Math.max(1, Math.floor(columns * CONFIG.headerColumnPercentage));
      
      for (let i = 0; i < columns; i++) {
        let pool = '';
        let poolColors = [];
        let hue = CONFIG.primaryColor;
        
        if (i < headerCols) {
          // Left: Block header data - no gold
          pool = data.headerData || '';
          poolColors = Array(pool.length).fill(false);
          hue = CONFIG.primaryColor;
        } else {
          // Right: UTXO data with gradient - mark bitcoin amounts as gold
          pool = data.utxoData || '';
          poolColors = Array(pool.length).fill(false);
          // Find bitcoin symbols and mark them + following digits as gold
          for (let j = 0; j < pool.length; j++) {
            if (pool[j] === '₿') {
              poolColors[j] = true;
              // Mark following digits and decimal point as gold
              for (let k = j + 1; k < pool.length; k++) {
                const ch = pool[k];
                if ((ch >= '0' && ch <= '9') || ch === '.') {
                  poolColors[k] = true;
                } else {
                  break; // Stop at first non-digit/non-decimal
                }
              }
            }
          }
          // Use uniform color for consistent brightness across screen
          hue = CONFIG.primaryColor;
        }
        if (!pool || !pool.length) {
          pool = '0123456789abcdef';
          poolColors = Array(pool.length).fill(false);
        }
        columnPools[i] = pool;
        columnPoolColors[i] = poolColors;
        columnIndex[i] = Math.floor(Math.random() * pool.length);
        columnHue[i] = hue;
      }
      
      // Ensure trail lengths are initialized
      if (columnTrailLength.length !== columns) {
        const maxTrail = Math.floor(H / fontSize * CONFIG.trailLengthMaxPercent);
        columnTrailLength = Array(columns).fill(0).map(() => Math.floor(CONFIG.trailLengthMin + Math.random() * (maxTrail - CONFIG.trailLengthMin)));
      }
    }

    async function fetchLatestTipHash() {
      const res = await fetch(`${API_BASE}/blocks/tip/hash`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Tip hash fetch failed: ${res.status}`);
      return (await res.text()).trim();
    }
    async function fetchBlockByHash(hash) {
      const res = await fetch(`${API_BASE}/block/${hash}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Block fetch failed: ${res.status}`);
      return res.json();
    }
    async function fetchBlockTxids(hash) {
      const res = await fetch(`${API_BASE}/block/${hash}/txids`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Block txids fetch failed: ${res.status}`);
      return res.json();
    }
    async function fetchTx(txid) {
      const res = await fetch(`${API_BASE}/tx/${txid}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Tx fetch failed: ${res.status}`);
      return res.json();
    }

    async function refreshLatestBlock() {
      try {
        setStatus('Fetching latest block from mempool.space…');
        const tipHash = await fetchLatestTipHash();
        if (!tipHash || tipHash === lastHash) {
          updateAgePill(latestBlock);
          setStatus('No new block; overlay refreshed.');
          return;
        }

        const block = await fetchBlockByHash(tipHash);
        latestBlock = block;
        lastHash = tipHash;
        
        // Trigger transition effect for new block
        triggerTransition();

        let txids = [];
        try { txids = await fetchBlockTxids(tipHash); } catch {}
        const txCount = Array.isArray(txids) ? txids.length : (block.tx_count ?? undefined);

        let coinbaseAscii = '';
        if (Array.isArray(txids) && txids.length) {
          try {
            const coinbaseTx = await fetchTx(txids[0]);
            const vin0 = coinbaseTx?.vin?.[0];
            const cbHex = vin0?.coinbase || vin0?.scriptsig || vin0?.scriptSig || '';
            coinbaseAscii = hexToAsciiSafe(cbHex);
          } catch {}
        }

        // Prepare block header data
        const headerData = [
          block.id || block.hash || '',
          block.merkle_root || '',
          'version' + block.version,
          'bits' + block.bits,
          'nonce' + block.nonce,
          'difficulty' + block.difficulty,
          'timestamp' + block.timestamp,
          'height' + block.height,
          coinbaseAscii
        ].join(' ').toLowerCase().replace(/[^a-z0-9 ]/g, '');

        // Fetch UTXO data from configured number of transactions
        const utxoStrings = [];
        const txLimit = Math.min(CONFIG.transactionFetchLimit, txids.length);
        setStatus(`Fetching UTXO data (${txLimit} transactions)…`);
        
        for (let i = 0; i < txLimit; i++) {
          try {
            const tx = await fetchTx(txids[i]);
            // Extract outputs (UTXOs)
            if (tx.vout) {
              for (const out of tx.vout) {
                const addr = out.scriptpubkey_address || 'unknown';
                const sats = out.value || 0;
                const btc = (sats / 100000000).toFixed(8);
                utxoStrings.push(`${addr} ₿${btc} ${tx.txid}`);
              }
            }
            // Extract inputs (previous outputs being spent)
            if (tx.vin) {
              for (const inp of tx.vin) {
                if (inp.prevout) {
                  const addr = inp.prevout.scriptpubkey_address || 'unknown';
                  const sats = inp.prevout.value || 0;
                  const btc = (sats / 100000000).toFixed(8);
                  utxoStrings.push(`${addr} ₿${btc} ${tx.txid}`);
                }
              }
            }
          } catch (e) {
            console.warn(`Failed to fetch tx ${txids[i]}:`, e);
          }
        }

        const utxoData = utxoStrings.join(' ').toLowerCase().replace(/[^a-z0-9₿. ]/g, '');
        
        const data = { headerData, utxoData };
        latestGlyphs = data;
        assignPoolsFromData(data);

        renderOverlay(block, txCount, coinbaseAscii);
        setStatus(`Updated to block ${block.height} (${tipHash.slice(0, 12)}…)`);
      } catch (e) {
        infoEl.textContent = `Error fetching from mempool.space: ${e.message}`;
        setStatus('Connection error; retrying soon…');
      }
    }

    // ===== Initialize Application =====
    async function initApp() {
      CONFIG = await loadConfig();
      fontSize = CONFIG.fontSize;
      API_BASE = CONFIG.apiBase;
      
      // Initialize matrix after config is loaded
      initColumns();
      drawMatrix();
      
      // Apply UI visibility settings
      applyUIVisibility();
      
      // Start block updates
      refreshLatestBlock();
      setInterval(refreshLatestBlock, CONFIG.blockRefreshInterval);
      setInterval(() => updateAgePill(latestBlock), CONFIG.ageUpdateInterval);
    }

    // Start the application
    initApp();
  </script>
</body>
</html>
