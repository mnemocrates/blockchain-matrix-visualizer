
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bitcoin Block – Data-Driven Matrix (mempool.space)</title>
  <style>
    :root {
      --matrix-green: #00ff7f;
      --matrix-dim: #00aa55;
      --matrix-deep: #008844;
      --bg-black: #000000;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --panel-bg: rgba(0, 0, 0, 0.6);
    }
    html, body {
      width: 100%; height: 100%;
      margin: 0; background: var(--bg-black);
      color: var(--matrix-green);
      font-family: var(--mono);
      overflow: hidden;
    }
    #canvas { position: fixed; inset: 0; display: block; background: #000; }
    #overlay {
      position: fixed; top: 1rem; left: 1rem;
      background: var(--panel-bg); border: 1px solid var(--matrix-dim);
      padding: 0.75rem 1rem; border-radius: 6px; backdrop-filter: blur(2px);
      box-shadow: 0 0 12px rgba(0,255,127,0.2); max-width: min(92vw, 56rem);
      cursor: pointer; transition: all 0.3s ease;
    }
    #overlay:hover { box-shadow: 0 0 18px rgba(0,255,127,0.35); }
    #overlay h1 {
      margin: 0 0 0.5rem 0; font-size: 1rem; letter-spacing: 0.08em;
      color: var(--matrix-green); text-shadow: 0 0 6px rgba(0,255,127,0.35);
      display: flex; align-items: center; gap: .5rem; flex-wrap: wrap;
    }
    #toggle-icon {
      margin-left: auto; font-size: 1.2rem; transition: transform 0.3s ease;
      user-select: none;
    }
    #overlay.collapsed #toggle-icon { transform: rotate(-90deg); }
    #overlay.collapsed #block-info,
    #overlay.collapsed #legend {
      max-height: 0; overflow: hidden; opacity: 0;
      margin: 0; transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    }
    #block-info, #legend {
      max-height: 1000px; opacity: 1;
      transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    }
    .pill {
      border: 1px solid var(--matrix-dim); border-radius: 999px;
      padding: 0.1rem 0.5rem; font-size: 0.85rem; color: var(--matrix-green);
    }
    #overlay pre { margin: 0.25rem 0 0 0; white-space: pre-wrap; word-break: break-all; color: var(--matrix-dim); line-height: 1.25; }
    #legend { margin-top: .5rem; color: var(--matrix-deep); font-size: .85rem; }
    #status {
      position: fixed; right: 1rem; bottom: 1rem;
      color: var(--matrix-dim); font-size: 0.8rem;
      background: var(--panel-bg); padding: .35rem .5rem; border-radius: 4px;
      border: 1px solid var(--matrix-dim);
    }
    a { color: var(--matrix-green); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .hidden-ui { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="overlay" class="collapsed hidden-ui">
    <h1>
      Latest Block ▮ Bitcoin <span class="pill">main</span>
      <span id="height" class="pill">Height: —</span>
      <span id="age" class="pill">Age: —</span>
      <span id="txcount" class="pill">Tx: —</span>
      <span id="source" class="pill">https://mempool.space/mempool.space</a></span>
      <span id="toggle-icon">▼</span>
    </h1>
    <pre id="block-info">Loading…</pre>
    <div id="legend">⬅︎ Block Header (left ~25%) • UTXO Data: addresses, amounts ₿, hashes (right ~75%)</div>
  </div>

  <div id="status" class="hidden-ui">Matrix connected to mempool.space…</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let W = window.innerWidth, H = window.innerHeight;
    const fontSize = 18;
    canvas.width = W; canvas.height = H;

    let columns = Math.floor(W / fontSize);
    let drops = [];
    let columnPools = [];
    let columnPoolColors = []; // Track which characters in pool should be gold
    let columnIndex = [];
    let columnHue = [];
    let columnTrailLength = [];
    let columnChars = []; // Current character for each column
    let columnLastPos = []; // Track last integer position
    let columnCharHistory = []; // History buffer for trailing characters
    let columnColorHistory = []; // Color history for each character

    function initColumns() {
      columns = Math.floor(W / fontSize);
      drops = Array(columns).fill(0).map(() => Math.random() * H / fontSize);
      columnPools = Array(columns).fill('');
      columnPoolColors = Array(columns).fill(null).map(() => []);
      columnIndex = Array(columns).fill(0);
      columnHue = Array(columns).fill('#00ff7f');
      const maxTrail = Math.floor(H / fontSize * 0.8); // Up to 80% of screen
      columnTrailLength = Array(columns).fill(0).map(() => Math.floor(5 + Math.random() * (maxTrail - 5)));
      columnChars = Array(columns).fill('');
      columnLastPos = Array(columns).fill(-1);
      columnCharHistory = Array(columns).fill(null).map(() => []);
      columnColorHistory = Array(columns).fill(null).map(() => []);
    }

    window.addEventListener('resize', () => {
      W = window.innerWidth; H = window.innerHeight;
      canvas.width = W; canvas.height = H;
      initColumns();
      assignPoolsFromData(latestGlyphs);
    });

    function nextGlyph(i) {
      const pool = columnPools[i] || '0123456789abcdef';
      if (!pool.length) return ' ';
      const ch = pool[columnIndex[i] % pool.length];
      columnIndex[i] = (columnIndex[i] + 1) % pool.length;
      return ch;
    }

    function drawMatrix() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, W, H);
      ctx.font = `${fontSize}px monospace`;
      
      // Rotate transactions every 20 seconds if we have transactions
      if (allTransactionData.length > 0 && Date.now() - lastRotationTime > 20000) {
        const headerCols = Math.max(1, Math.floor(columns * 0.25));
        const txCols = columns - headerCols;
        transactionOffset = (transactionOffset + txCols) % allTransactionData.length;
        lastRotationTime = Date.now();
        assignPoolsFromData(latestGlyphs);
      }

      for (let i = 0; i < drops.length; i++) {
        const currentPos = Math.floor(drops[i]);
        // Only get new character when position changes
        if (currentPos !== columnLastPos[i]) {
          columnChars[i] = nextGlyph(i);
          columnLastPos[i] = currentPos;
          // Get color from pool color array
          const ch = columnChars[i];
          const poolColors = columnPoolColors[i];
          const idx = (columnIndex[i] - 1 + poolColors.length) % poolColors.length;
          const isGold = poolColors[idx] || false;
          // Add new character and its color to history buffers
          columnCharHistory[i].unshift(ch);
          columnColorHistory[i].unshift(isGold);
          // Keep history buffer size manageable (max trail length + some extra)
          const maxHistory = Math.floor(H / fontSize);
          if (columnCharHistory[i].length > maxHistory) {
            columnCharHistory[i].length = maxHistory;
            columnColorHistory[i].length = maxHistory;
          }
        }
        const ch = columnChars[i];
        const x = i * fontSize;
        const y = currentPos * fontSize;

        // Bright leading character
        const isGoldChar = columnColorHistory[i][0];
        ctx.fillStyle = isGoldChar ? '#FFD700' : columnHue[i];
        ctx.fillText(ch, x, y);

        // Draw variable length fading trail
        const baseHue = columnHue[i];
        let r, g, b;
        if (baseHue.startsWith('#')) {
          r = parseInt(baseHue.slice(1, 3), 16);
          g = parseInt(baseHue.slice(3, 5), 16);
          b = parseInt(baseHue.slice(5, 7), 16);
        } else if (baseHue.startsWith('rgb')) {
          const match = baseHue.match(/\d+/g);
          if (match) {
            r = parseInt(match[0]);
            g = parseInt(match[1]);
            b = parseInt(match[2]);
          } else {
            r = 0; g = 170; b = 85;
          }
        } else {
          r = 0; g = 170; b = 85;
        }
        
        // Draw trailing characters with exponential fade for readability
        const trailLen = columnTrailLength[i];
        const history = columnCharHistory[i];
        for (let j = 1; j <= trailLen; j++) {
          const trailY = y - (j * fontSize);
          if (trailY < -fontSize || trailY > H) continue;
          
          // Exponential fade: starts at 50% and drops rapidly
          const fadeRatio = j / trailLen;
          const opacity = 0.5 * Math.pow(1 - fadeRatio, 2);
          
          if (opacity > 0.05) {
            // Use character from history if available, otherwise current char
            const trailChar = history[j] || ch;
            const trailIsGold = columnColorHistory[i][j];
            if (trailIsGold) {
              ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
            } else {
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            ctx.fillText(trailChar, x, trailY);
          }
        }

        if (y > H && Math.random() > 0.975) drops[i] = 0;
        drops[i] += 0.5; // Slow movement but characters stay on grid
      }
      requestAnimationFrame(drawMatrix);
    }

    initColumns();
    drawMatrix();

    // ===== Keyboard Toggle =====
    window.addEventListener('keydown', (e) => {
      if (e.key === 's' || e.key === 'S') {
        overlayEl.classList.toggle('hidden-ui');
        statusEl.classList.toggle('hidden-ui');
      }
    });

    // ===== Expandable Header =====
    const overlayEl = document.getElementById('overlay');
    overlayEl.addEventListener('click', () => {
      overlayEl.classList.toggle('collapsed');
    });

    // ===== Live Data =====
    const heightPill = document.getElementById('height');
    const agePill = document.getElementById('age');
    const txPill = document.getElementById('txcount');
    const infoEl = document.getElementById('block-info');
    const statusEl = document.getElementById('status');
    const sourceLink = document.getElementById('sourceLink');

    const API_BASE = 'https://mempool.space/api';
    let lastHash = null;
    let latestBlock = null;
    let latestGlyphs = null;
    let allTransactionData = []; // Array of transaction data strings
    let transactionOffset = 0; // Current offset for transaction rotation
    let lastRotationTime = Date.now();

    function setStatus(msg) { statusEl.textContent = msg; }
    function toLowerStr(val) { return (val ?? '') === '' ? '' : String(val).toLowerCase(); }
    function toHexStr(val) {
      if (val === undefined || val === null) return '';
      if (typeof val === 'string') return val.toLowerCase();
      if (typeof val === 'number') { try { return (val >>> 0).toString(16); } catch { return String(val); } }
      return String(val).toLowerCase();
    }
    function hexToAsciiSafe(hex) {
      if (!hex || typeof hex !== 'string') return '';
      const cleaned = hex.replace(/[^0-9a-fA-F]/g, '');
      let out = '';
      for (let i = 0; i < cleaned.length; i += 2) {
        const b = parseInt(cleaned.slice(i, i + 2), 16);
        if (!isNaN(b)) {
          const ch = String.fromCharCode(b);
          if (ch >= ' ' && ch <= '~') out += ch;
        }
      }
      return out.toLowerCase();
    }
    function updateAgePill(block) {
      if (!block || !block.timestamp) { agePill.textContent = 'Age: —'; return; }
      const secs = Math.max(0, Math.floor(Date.now()/1000) - block.timestamp);
      const mins = Math.floor(secs / 60);
      const rem = secs % 60;
      agePill.textContent = `Age: ${mins}m ${rem}s`;
    }

    function renderOverlay(block, txCount, coinbaseAscii) {
      heightPill.textContent = `Height: ${block.height ?? '—'}`;
      txPill.textContent = `Tx: ${txCount ?? '—'}`;

      const lines = [
        `Hash:       ${block.id ?? block.hash ?? '—'}`,
        `Time:       ${block.timestamp ? new Date(block.timestamp * 1000).toISOString() + ' (' + block.timestamp + ')' : '—'}`,
        `Tx Count:   ${txCount ?? '—'}`,
        `Size:       ${block.size ?? '—'} bytes`,
        `Weight:     ${block.weight ?? '—'} wu`,
        `Version:    ${block.version ?? '—'} (0x${block.version != null ? block.version.toString(16) : '—'})`,
        `Merkle:     ${block.merkle_root ?? '—'}`,
        `Difficulty: ${block.difficulty ?? '—'}`,
        `Bits:       ${block.bits ?? '—'}`,
        `Nonce:      ${block.nonce ?? '—'} (0x${block.nonce != null ? block.nonce.toString(16) : '—'})`,
        `Prev:       ${block.previousblockhash ?? '—'}`,
        `Median:     ${block.mediantime ? new Date(block.mediantime * 1000).toISOString() + ' (' + block.mediantime + ')' : '—'}`,
        coinbaseAscii ? `Coinbase:   "${coinbaseAscii.slice(0, 120)}${coinbaseAscii.length > 120 ? '…' : ''}"` : `Coinbase:   —`,
      ];
      infoEl.textContent = lines.join('\n');
      updateAgePill(block);

      const hashForLink = block.id ?? block.hash;
      if (sourceLink) {
        sourceLink.href = hashForLink
          ? `https://mempool.space/block/${hashForLink}`
          : 'https://mempool.space/';
      }
    }

    function assignPoolsFromData(data) {
      if (!data) return;
      const headerCols = Math.max(1, Math.floor(columns * 0.25)); // Left 25% for header
      const txCols = columns - headerCols; // Number of transaction columns
      
      for (let i = 0; i < columns; i++) {
        let pool = '';
        let poolColors = [];
        let hue = '#00ff7f';
        
        if (i < headerCols) {
          // Left: Block header data - no gold
          pool = data.headerData || '';
          poolColors = Array(pool.length).fill(false);
          hue = '#00ff7f';
        } else {
          // Right: Assign one transaction per column
          const colIndex = i - headerCols;
          const txIndex = (transactionOffset + colIndex) % Math.max(1, allTransactionData.length);
          pool = allTransactionData[txIndex] || '';
          poolColors = Array(pool.length).fill(false);
          // Find bitcoin symbols and mark them + following digits as gold
          for (let j = 0; j < pool.length; j++) {
            if (pool[j] === '₿') {
              poolColors[j] = true;
              // Mark following digits and decimal point as gold
              for (let k = j + 1; k < pool.length; k++) {
                const ch = pool[k];
                if ((ch >= '0' && ch <= '9') || ch === '.') {
                  poolColors[k] = true;
                } else {
                  break; // Stop at first non-digit/non-decimal
                }
              }
            }
          }
          const progress = colIndex / Math.max(1, txCols - 1);
          const g = Math.floor(170 - progress * 34); // 170 -> 136
          const b = Math.floor(85 - progress * 17);  // 85 -> 68
          hue = `rgb(0, ${g}, ${b})`;
        }

        if (!pool || !pool.length) {
          pool = '0123456789abcdef';
          poolColors = Array(pool.length).fill(false);
        }
        columnPools[i] = pool;
        columnPoolColors[i] = poolColors;
        columnIndex[i] = Math.floor(Math.random() * pool.length);
        columnHue[i] = hue;
      }
      
      // Ensure trail lengths are initialized
      if (columnTrailLength.length !== columns) {
        const maxTrail = Math.floor(H / fontSize * 0.8);
        columnTrailLength = Array(columns).fill(0).map(() => Math.floor(5 + Math.random() * (maxTrail - 5)));
      }
    }

    async function fetchLatestTipHash() {
      const res = await fetch(`${API_BASE}/blocks/tip/hash`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Tip hash fetch failed: ${res.status}`);
      return (await res.text()).trim();
    }
    async function fetchBlockByHash(hash) {
      const res = await fetch(`${API_BASE}/block/${hash}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Block fetch failed: ${res.status}`);
      return res.json();
    }
    async function fetchBlockTxids(hash) {
      const res = await fetch(`${API_BASE}/block/${hash}/txids`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Block txids fetch failed: ${res.status}`);
      return res.json();
    }
    async function fetchTx(txid) {
      const res = await fetch(`${API_BASE}/tx/${txid}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Tx fetch failed: ${res.status}`);
      return res.json();
    }

    async function refreshLatestBlock() {
      try {
        setStatus('Fetching latest block from mempool.space…');
        const tipHash = await fetchLatestTipHash();
        if (!tipHash || tipHash === lastHash) {
          updateAgePill(latestBlock);
          setStatus('No new block; overlay refreshed.');
          return;
        }

        const block = await fetchBlockByHash(tipHash);
        latestBlock = block;
        lastHash = tipHash;

        let txids = [];
        try { txids = await fetchBlockTxids(tipHash); } catch {}
        const txCount = Array.isArray(txids) ? txids.length : (block.tx_count ?? undefined);

        let coinbaseAscii = '';
        if (Array.isArray(txids) && txids.length) {
          try {
            const coinbaseTx = await fetchTx(txids[0]);
            const vin0 = coinbaseTx?.vin?.[0];
            const cbHex = vin0?.coinbase || vin0?.scriptsig || vin0?.scriptSig || '';
            coinbaseAscii = hexToAsciiSafe(cbHex);
          } catch {}
        }

        // Prepare block header data
        const headerData = [
          block.id || block.hash || '',
          block.merkle_root || '',
          'version' + block.version,
          'bits' + block.bits,
          'nonce' + block.nonce,
          'difficulty' + block.difficulty,
          'timestamp' + block.timestamp,
          'height' + block.height,
          coinbaseAscii
        ].join(' ').toLowerCase().replace(/[^a-z0-9 ]/g, '');

        // Fetch ALL transactions from the block
        allTransactionData = [];
        transactionOffset = 0;
        lastRotationTime = Date.now();
        setStatus(`Fetching all ${txids.length} transactions…`);
        
        for (let i = 0; i < txids.length; i++) {
          try {
            const tx = await fetchTx(txids[i]);
            const txData = [];
            // Extract outputs (UTXOs)
            if (tx.vout) {
              for (const out of tx.vout) {
                const addr = out.scriptpubkey_address || 'unknown';
                const sats = out.value || 0;
                const btc = (sats / 100000000).toFixed(8);
                txData.push(`${addr} ₿${btc}`);
              }
            }
            // Extract inputs (previous outputs being spent)
            if (tx.vin) {
              for (const inp of tx.vin) {
                if (inp.prevout) {
                  const addr = inp.prevout.scriptpubkey_address || 'unknown';
                  const sats = inp.prevout.value || 0;
                  const btc = (sats / 100000000).toFixed(8);
                  txData.push(`${addr} ₿${btc}`);
                }
              }
            }
            // Add transaction ID at the end
            txData.push(tx.txid);
            const txString = txData.join(' ').toLowerCase().replace(/[^a-z0-9₿. ]/g, '');
            allTransactionData.push(txString);
          } catch (e) {
            console.warn(`Failed to fetch tx ${txids[i]}:`, e);
            allTransactionData.push('error');
          }
        }
        
        const data = { headerData };
        latestGlyphs = data;
        assignPoolsFromData(data);

        renderOverlay(block, txCount, coinbaseAscii);
        setStatus(`Updated to block ${block.height} (${tipHash.slice(0, 12)}…)`);
      } catch (e) {
        infoEl.textContent = `Error fetching from mempool.space: ${e.message}`;
        setStatus('Connection error; retrying soon…');
      }
    }

    refreshLatestBlock();
    setInterval(refreshLatestBlock, 30000);
    setInterval(() => updateAgePill(latestBlock), 1000);
  </script>
</body>
</html>
